From d8d86c987013fd51ff6377af419e03819dd481bb Mon Sep 17 00:00:00 2001
From: Mika Laitio <lamikr@gmail.com>
Date: Wed, 28 Aug 2024 16:59:54 -0700
Subject: [PATCH 2/4] renove tensorflow related classes

Signed-off-by: Mika Laitio <lamikr@gmail.com>
---
 rocAL/include/meta_data/tf_meta_data_reader.h |  66 ----
 .../meta_data/tf_meta_data_reader_detection.h |  68 ----
 .../include/readers/image/tf_record_reader.h  | 118 -------
 .../source/meta_data/tf_meta_data_reader.cpp  | 181 -----------
 .../tf_meta_data_reader_detection.cpp         | 250 --------------
 .../source/readers/image/tf_record_reader.cpp | 304 ------------------
 tests/python_api/tf_classification_reader.py  | 112 -------
 tests/python_api/tf_detection_reader.py       | 164 ----------
 8 files changed, 1263 deletions(-)
 delete mode 100644 rocAL/include/meta_data/tf_meta_data_reader.h
 delete mode 100644 rocAL/include/meta_data/tf_meta_data_reader_detection.h
 delete mode 100644 rocAL/include/readers/image/tf_record_reader.h
 delete mode 100644 rocAL/source/meta_data/tf_meta_data_reader.cpp
 delete mode 100644 rocAL/source/meta_data/tf_meta_data_reader_detection.cpp
 delete mode 100644 rocAL/source/readers/image/tf_record_reader.cpp
 delete mode 100644 tests/python_api/tf_classification_reader.py
 delete mode 100644 tests/python_api/tf_detection_reader.py

diff --git a/rocAL/include/meta_data/tf_meta_data_reader.h b/rocAL/include/meta_data/tf_meta_data_reader.h
deleted file mode 100644
index 1646425..0000000
--- a/rocAL/include/meta_data/tf_meta_data_reader.h
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
-Copyright (c) 2019 - 2023 Advanced Micro Devices, Inc. All rights reserved.
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-THE SOFTWARE.
-*/
-#pragma once
-#include <dirent.h>
-
-#include <list>
-#include <map>
-#include <memory>
-#include <variant>
-
-#include "pipeline/commons.h"
-#include "meta_data/meta_data.h"
-#include "meta_data/meta_data_reader.h"
-
-class TFMetaDataReader : public MetaDataReader {
-   public:
-    void init(const MetaDataConfig &cfg, pMetaDataBatch meta_data_batch) override;
-    void lookup(const std::vector<std::string> &image_names) override;
-    void read_all(const std::string &path) override;
-    void release(std::string image_name);
-    void release() override;
-    void print_map_contents();
-    bool set_timestamp_mode() override { return false; }
-
-    const std::map<std::string, std::shared_ptr<MetaData>> &get_map_content() override { return _map_content; }
-    TFMetaDataReader();
-
-   private:
-    void read_files(const std::string &_path);
-    bool exists(const std::string &image_name) override;
-    void add(std::string image_name, int label);
-    bool _last_rec;
-    size_t _file_id = 0;
-    // std::shared_ptr<TF_Read> _TF_read = nullptr;
-    void read_record(std::ifstream &file_contents, uint file_size, std::vector<std::string> &image_name, std::string user_label_key, std::string user_filename_key);
-    void incremenet_file_id() { _file_id++; }
-    std::map<std::string, std::shared_ptr<MetaData>> _map_content;
-    std::map<std::string, std::shared_ptr<MetaData>>::iterator _itr;
-    std::string _path;
-    std::map<std::string, std::string> _feature_key_map;
-    pMetaDataBatch _output;
-    DIR *_src_dir;
-    struct dirent *_entity;
-    std::vector<std::string> _file_names;
-    std::vector<std::string> _subfolder_file_names;
-    std::vector<std::string> _image_name;
-};
\ No newline at end of file
diff --git a/rocAL/include/meta_data/tf_meta_data_reader_detection.h b/rocAL/include/meta_data/tf_meta_data_reader_detection.h
deleted file mode 100644
index 0be6e3b..0000000
--- a/rocAL/include/meta_data/tf_meta_data_reader_detection.h
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
-Copyright (c) 2019 - 2023 Advanced Micro Devices, Inc. All rights reserved.
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-THE SOFTWARE.
-*/
-
-#pragma once
-#include <dirent.h>
-
-#include <list>
-#include <map>
-#include <memory>
-#include <variant>
-
-#include "pipeline/commons.h"
-#include "meta_data/meta_data.h"
-#include "meta_data/meta_data_reader.h"
-
-class TFMetaDataReaderDetection : public MetaDataReader {
-   public:
-    void init(const MetaDataConfig &cfg, pMetaDataBatch meta_data_batch) override;
-    void lookup(const std::vector<std::string> &image_names) override;
-    void read_all(const std::string &path) override;
-    void release(std::string image_name);
-    void release() override;
-    void print_map_contents();
-    bool set_timestamp_mode() override { return false; }
-
-    const std::map<std::string, std::shared_ptr<MetaData>> &get_map_content() override { return _map_content; }
-    TFMetaDataReaderDetection();
-
-   private:
-    void read_files(const std::string &_path);
-    bool exists(const std::string &image_name) override;
-    // bbox add
-    void add(std::string image_name, BoundingBoxCords bbox, Labels labels, ImgSize image_size);
-    bool _last_rec;
-    void read_record(std::ifstream &file_contents, uint file_size, std::vector<std::string> &image_name,
-                     std::string user_label_key, std::string user_text_key,
-                     std::string user_xmin_key, std::string user_ymin_key, std::string user_xmax_key, std::string user_ymax_key,
-                     std::string user_filename_key);  // std::map<std::string, std::shared_ptr<Label>> _map_content;
-    std::map<std::string, std::shared_ptr<MetaData>> _map_content;
-    std::map<std::string, std::shared_ptr<MetaData>>::iterator _itr;
-    std::string _path;
-    pMetaDataBatch _output;
-    DIR *_src_dir;
-    struct dirent *_entity;
-    std::map<std::string, std::string> _feature_key_map;
-    std::vector<std::string> _file_names;
-    std::vector<std::string> _subfolder_file_names;
-    std::vector<std::string> _image_name;
-};
diff --git a/rocAL/include/readers/image/tf_record_reader.h b/rocAL/include/readers/image/tf_record_reader.h
deleted file mode 100644
index 1810ffa..0000000
--- a/rocAL/include/readers/image/tf_record_reader.h
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
-Copyright (c) 2019 - 2023 Advanced Micro Devices, Inc. All rights reserved.
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-THE SOFTWARE.
-*/
-
-#pragma once
-#include <dirent.h>
-#include <google/protobuf/message_lite.h>
-
-#include <algorithm>
-#include <iterator>
-#include <map>
-#include <memory>
-#include <string>
-#include <vector>
-
-#include "example.pb.h"
-#include "feature.pb.h"
-#include "readers/image/image_reader.h"
-#include "pipeline/timing_debug.h"
-
-class TFRecordReader : public Reader {
-   public:
-    //! Reads the TFRecord File, and loads the image ids and other necessary info
-    /*!
-     \param desc  User provided descriptor containing the files' path.
-    */
-    Reader::Status initialize(ReaderConfig desc) override;
-    //! Reads the next resource item
-    /*!
-     \param buf User's provided buffer to receive the loaded images
-     \return Size of the loaded resource
-    */
-    size_t read_data(unsigned char *buf, size_t max_size) override;
-    //! Opens the next file in the folder
-    /*!
-     \return The size of the next file, 0 if couldn't access it
-    */
-    size_t open() override;
-    //! Resets the object's state to read from the first file in the folder
-    void reset() override;
-
-    //! Returns the id of the latest file opened
-    std::string id() override { return _last_id; };
-
-    unsigned count_items() override;
-
-    ~TFRecordReader() override;
-
-    int close() override;
-
-    TFRecordReader();
-
-   private:
-    //! opens the folder containnig the images
-    Reader::Status tf_record_reader();
-    Reader::Status folder_reading();
-    std::string _folder_path;
-    std::string _path;
-    std::map<std::string, std::string> _feature_key_map;
-    std::string _encoded_key;
-    std::string _filename_key;
-    DIR *_src_dir;
-    DIR *_sub_dir;
-    struct dirent *_entity;
-    std::vector<std::string> _file_names;
-    std::map<std::string, unsigned int> _file_size;
-    unsigned _curr_file_idx;
-    unsigned _current_file_size;
-    std::string _last_id;
-    std::string _last_file_name;
-    unsigned int _last_file_size;
-    size_t _shard_id = 0;
-    size_t _shard_count = 1;  // equivalent of batch size
-    bool _last_rec;
-    //!< _batch_count Defines the quantum count of the images to be read. It's usually equal to the user's batch size.
-    /// The loader will repeat images if necessary to be able to have images available in multiples of the load_batch_count,
-    /// for instance if there are 10 images in the dataset and _batch_count is 3, the loader repeats 2 images as if there are 12 images available.
-    size_t _batch_count = 1;
-    size_t _file_id = 0;
-    size_t _in_batch_read_count = 0;
-    bool _loop;
-    bool _shuffle;
-    int _read_counter = 0;
-    size_t _file_count_all_shards;
-    //!< _record_name_prefix tells the reader to read only files with the prefix
-    std::string _record_name_prefix;
-    // protobuf message objects
-    tensorflow::Example _single_example;
-    tensorflow::Features _features;
-    tensorflow::Feature _single_feature;
-    void incremenet_read_ptr();
-    int release();
-    size_t get_file_shard_id();
-    void incremenet_file_id() { _file_id++; }
-    void replicate_last_image_to_fill_last_shard();
-    void replicate_last_batch_to_pad_partial_shard();
-    Reader::Status read_image(unsigned char *buff, std::string record_file_name, uint file_size);
-    Reader::Status read_image_names(std::ifstream &file_contents, uint file_size);
-    std::map<std::string, uint> _image_record_starting;
-};
diff --git a/rocAL/source/meta_data/tf_meta_data_reader.cpp b/rocAL/source/meta_data/tf_meta_data_reader.cpp
deleted file mode 100644
index 7d5fe50..0000000
--- a/rocAL/source/meta_data/tf_meta_data_reader.cpp
+++ /dev/null
@@ -1,181 +0,0 @@
-/*
-Copyright (c) 2019 - 2023 Advanced Micro Devices, Inc. All rights reserved.
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-THE SOFTWARE.
-*/
-
-#include "meta_data/tf_meta_data_reader.h"
-
-#include <google/protobuf/message_lite.h>
-#include <stdint.h>
-
-#include <algorithm>
-#include <fstream>
-#include <iostream>
-#include <string>
-#include <utility>
-
-#include "example.pb.h"
-#include "feature.pb.h"
-
-using namespace std;
-
-void TFMetaDataReader::init(const MetaDataConfig &cfg, pMetaDataBatch meta_data_batch) {
-    _path = cfg.path();
-    _feature_key_map = cfg.feature_key_map();
-    _output = meta_data_batch;
-    _last_rec = false;
-}
-
-bool TFMetaDataReader::exists(const std::string &_image_name) {
-    return _map_content.find(_image_name) != _map_content.end();
-}
-
-void TFMetaDataReader::add(std::string image_name, int label) {
-    pMetaData info = std::make_shared<Label>(label);
-    if (exists(image_name)) {
-        WRN("Entity with the same name exists")
-        return;
-    }
-    _map_content.insert(std::pair<std::string, std::shared_ptr<Label>>(image_name, info));
-}
-
-void TFMetaDataReader::lookup(const std::vector<std::string> &_image_names) {
-    if (_image_names.empty()) {
-        WRN("No image names passed")
-        return;
-    }
-    if (_image_names.size() != (unsigned)_output->size())
-        _output->resize(_image_names.size());
-
-    for (unsigned i = 0; i < _image_names.size(); i++) {
-        auto _image_name = _image_names[i];
-        auto it = _map_content.find(_image_name);
-        if (_map_content.end() == it)
-            THROW("ERROR: Given name not present in the map" + _image_name)
-        _output->get_labels_batch()[i] = it->second->get_labels();
-    }
-}
-
-void TFMetaDataReader::print_map_contents() {
-    std::cerr << "\nMap contents: \n";
-    for (auto &elem : _map_content) {
-        std::cerr << "Name :\t " << elem.first << "\t ID:  " << elem.second->get_labels()[0] << std::endl;
-    }
-}
-
-void TFMetaDataReader::read_record(std::ifstream &file_contents, uint file_size, std::vector<std::string> &_image_name, std::string user_label_key, std::string user_filename_key) {
-    // std::cerr << "The user_label_key is " << user_label_key << ", and the user_filename_key is " << user_filename_key << "\n";
-    uint length;
-    uint64_t data_length;
-    uint32_t length_crc, data_crc;
-
-    length = file_contents.tellg();
-    file_contents.read((char *)&data_length, sizeof(data_length));
-    if (!file_contents)
-        THROW("TFMetaDataReader: Error in reading TF records")
-    file_contents.read((char *)&length_crc, sizeof(length_crc));
-    if (!file_contents)
-        THROW("TFMetaDataReader: Error in reading TF records")
-    if (length + data_length + 16 == file_size) {
-        _last_rec = true;
-    }
-    char *data = new char[data_length];
-    file_contents.read(data, data_length);
-    if (!file_contents)
-        THROW("TFMetaDataReader: Error in reading TF records")
-    tensorflow::Example single_example;
-    single_example.ParseFromArray(data, data_length);
-    tensorflow::Features features = single_example.features();
-    // features.PrintDebugString();
-    auto feature = features.feature();
-    tensorflow::Feature single_feature;
-    std::string fname;
-    if (!user_filename_key.empty()) {
-        single_feature = feature.at(user_filename_key);
-        fname = single_feature.bytes_list().value()[0];
-    } else {
-        // adding for raw images
-        fname = std::to_string(_file_id);
-        incremenet_file_id();
-    }
-    _image_name.push_back(fname);
-    uint label;
-    single_feature = feature.at(user_label_key);
-    label = single_feature.int64_list().value()[0];
-    // std::cout << "TFMeta read record <name, label>" << fname << " " << label << std::endl;
-    add(fname, label);
-    file_contents.read((char *)&data_crc, sizeof(data_crc));
-    if (!file_contents)
-        THROW("TFMetaDataReader: Error in reading TF records")
-    delete[] data;
-}
-
-void TFMetaDataReader::read_all(const std::string &path) {
-    std::string label_key = "image/class/label";
-    std::string filename_key = "image/filename";
-    label_key = _feature_key_map.at(label_key);
-    filename_key = _feature_key_map.at(filename_key);
-
-    read_files(path);
-    for (unsigned i = 0; i < _file_names.size(); i++) {
-        std::string fname = path + "/" + _file_names[i];
-        uint length;
-        std::cerr << "Reading for image classification - file_name:: " << fname << std::endl;
-        std::ifstream file_contents(fname.c_str(), std::ios::binary);
-        file_contents.seekg(0, std::ifstream::end);
-        length = file_contents.tellg();
-        file_contents.seekg(0, std::ifstream::beg);
-        while (!_last_rec) {
-            read_record(file_contents, length, _image_name, label_key, filename_key);
-        }
-        _last_rec = false;
-        file_contents.close();
-    }
-}
-
-void TFMetaDataReader::release(std::string _image_name) {
-    if (!exists(_image_name)) {
-        WRN("ERROR: Given not present in the map" + _image_name);
-        return;
-    }
-    _map_content.erase(_image_name);
-}
-
-void TFMetaDataReader::release() {
-    _map_content.clear();
-}
-
-void TFMetaDataReader::read_files(const std::string &_path) {
-    if ((_src_dir = opendir(_path.c_str())) == nullptr)
-        THROW("ERROR: Failed opening the directory at " + _path);
-
-    while ((_entity = readdir(_src_dir)) != nullptr) {
-        if (_entity->d_type != DT_REG)
-            continue;
-
-        _file_names.push_back(_entity->d_name);
-    }
-    if (_file_names.empty())
-        WRN("TFMetadataReader: Could not find any file in " + _path)
-    closedir(_src_dir);
-}
-
-TFMetaDataReader::TFMetaDataReader() {
-}
diff --git a/rocAL/source/meta_data/tf_meta_data_reader_detection.cpp b/rocAL/source/meta_data/tf_meta_data_reader_detection.cpp
deleted file mode 100644
index 22b1a3d..0000000
--- a/rocAL/source/meta_data/tf_meta_data_reader_detection.cpp
+++ /dev/null
@@ -1,250 +0,0 @@
-/*
-Copyright (c) 2019 - 2023 Advanced Micro Devices, Inc. All rights reserved.
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-THE SOFTWARE.
-*/
-
-#include "meta_data/tf_meta_data_reader_detection.h"
-
-#include <google/protobuf/message_lite.h>
-#include <stdint.h>
-
-#include <algorithm>
-#include <fstream>
-#include <iostream>
-#include <string>
-#include <utility>
-
-#include "example.pb.h"
-#include "feature.pb.h"
-
-using namespace std;
-
-void TFMetaDataReaderDetection::init(const MetaDataConfig &cfg, pMetaDataBatch meta_data_batch) {
-    _path = cfg.path();
-    _feature_key_map = cfg.feature_key_map();
-    _output = meta_data_batch;
-    _last_rec = false;
-}
-
-bool TFMetaDataReaderDetection::exists(const std::string &_image_name) {
-    return _map_content.find(_image_name) != _map_content.end();
-}
-
-void TFMetaDataReaderDetection::add(std::string image_name, BoundingBoxCords bb_coords, Labels bb_labels, ImgSize image_size) {
-    if (exists(image_name)) {
-        auto it = _map_content.find(image_name);
-        it->second->get_bb_cords().push_back(bb_coords[0]);
-        it->second->get_labels().push_back(bb_labels[0]);
-        return;
-    }
-    pMetaDataBox info = std::make_shared<BoundingBox>(bb_coords, bb_labels, image_size);
-    _map_content.insert(pair<std::string, std::shared_ptr<BoundingBox>>(image_name, info));
-}
-
-void TFMetaDataReaderDetection::lookup(const std::vector<std::string> &image_names) {
-    if (image_names.empty()) {
-        WRN("No image names passed")
-        return;
-    }
-    if (image_names.size() != (unsigned)_output->size())
-        _output->resize(image_names.size());
-
-    for (unsigned i = 0; i < image_names.size(); i++) {
-        auto image_name = image_names[i];
-        auto it = _map_content.find(image_name);
-
-        if (_map_content.end() == it)
-            THROW("ERROR: Given name not present in the map" + image_name)
-        _output->get_bb_cords_batch()[i] = it->second->get_bb_cords();
-        _output->get_labels_batch()[i] = it->second->get_labels();
-        _output->get_img_sizes_batch()[i] = it->second->get_img_size();
-    }
-}
-
-void TFMetaDataReaderDetection::print_map_contents() {
-    BoundingBoxCords bb_coords;
-    Labels bb_labels;
-
-    std::cerr << "\nMap contents: \n";
-    for (auto &elem : _map_content) {
-        std::cerr << "Name :\t " << elem.first;
-        bb_coords = elem.second->get_bb_cords();
-        bb_labels = elem.second->get_labels();
-        std::cerr << "\nsize of the element  : " << bb_coords.size() << std::endl;
-        for (unsigned int i = 0; i < bb_coords.size(); i++) {
-            std::cerr << " l : " << bb_coords[i].l << " t: :" << bb_coords[i].t << " r : " << bb_coords[i].r << " b: :" << bb_coords[i].b << std::endl;
-            std::cerr << "Label Id : " << bb_labels[i] << std::endl;
-        }
-    }
-}
-
-void TFMetaDataReaderDetection::read_record(std::ifstream &file_contents, uint file_size, std::vector<std::string> &_image_name,
-                                            std::string user_label_key, std::string user_text_key,
-                                            std::string user_xmin_key, std::string user_ymin_key, std::string user_xmax_key, std::string user_ymax_key,
-                                            std::string user_filename_key) {
-    uint length;
-    length = file_contents.tellg();
-
-    std::string temp;
-    size_t uint64_size, uint32_size;
-    uint64_t data_length;
-    uint32_t length_crc, data_crc;
-    uint64_size = sizeof(uint64_t);
-    uint32_size = sizeof(uint32_t);
-    char *header_length = new char[uint64_size];
-    char *header_crc = new char[uint32_size];
-    char *footer_crc = new char[uint32_size];
-    file_contents.read(header_length, uint64_size);
-    if (!file_contents)
-        THROW("TFMetaDataReaderDetection: Error in reading TF records")
-    file_contents.read(header_crc, uint32_size);
-    if (!file_contents)
-        THROW("TFMetaDataReaderDetection: Error in reading TF records")
-    memcpy(&data_length, header_length, sizeof(data_length));
-    memcpy(&length_crc, header_crc, sizeof(length_crc));
-
-    if (length + data_length + 16 == file_size) {
-        _last_rec = true;
-    }
-    char *data = new char[data_length];
-    file_contents.read(data, data_length);
-    if (!file_contents)
-        THROW("TFMetaDataReaderDetection: Error in reading TF records")
-    tensorflow::Example single_example;
-    single_example.ParseFromArray(data, data_length);
-    tensorflow::Features features = single_example.features();
-
-    auto feature = features.feature();
-    tensorflow::Feature single_feature, sf_xmin, sf_ymin, sf_xmax, sf_ymax, sf_fname, sf_label, sf_height, sf_width;
-
-    single_feature = feature.at(user_filename_key);
-    std::string fname = single_feature.bytes_list().value()[0];
-    float size_b_xmin;
-    single_feature = feature.at(user_xmin_key);
-    size_b_xmin = single_feature.float_list().value().size();
-
-    BoundingBoxCords bb_coords;
-    Labels bb_labels;
-    BoundingBoxCord box;
-
-    sf_label = feature.at(user_label_key);
-    sf_xmin = feature.at(user_xmin_key);
-    sf_ymin = feature.at(user_ymin_key);
-    sf_xmax = feature.at(user_xmax_key);
-    sf_ymax = feature.at(user_ymax_key);
-
-    sf_height = feature.at("image/height");
-    sf_width = feature.at("image/width");
-
-    int image_height, image_width;
-    image_height = sf_height.int64_list().value()[0];
-    image_width = sf_width.int64_list().value()[0];
-
-    ImgSize img_size;
-    img_size.w = image_width;
-    img_size.h = image_height;
-
-    for (int i = 0; i < size_b_xmin; i++) {
-        int label;
-        label = sf_label.int64_list().value()[i];
-        box.l = sf_xmin.float_list().value()[i] * image_width;
-        box.t = sf_ymin.float_list().value()[i] * image_height;
-        box.r = sf_xmax.float_list().value()[i] * image_width;
-        box.b = sf_ymax.float_list().value()[i] * image_height;
-        bb_coords.push_back(box);
-        bb_labels.push_back(label);
-        add(fname, bb_coords, bb_labels, img_size);
-        bb_coords.clear();
-        bb_labels.clear();
-    }
-    file_contents.read(footer_crc, sizeof(data_crc));
-    if (!file_contents)
-        THROW("TFMetaDataReaderDetection: Error in reading TF records")
-    memcpy(&data_crc, footer_crc, sizeof(data_crc));
-    delete[] header_length;
-    delete[] header_crc;
-    delete[] footer_crc;
-    delete[] data;
-}
-
-void TFMetaDataReaderDetection::read_all(const std::string &path) {
-    std::string label_key = "image/class/label";
-    std::string text_key = "image/class/text";
-    std::string xmin_key = "image/object/bbox/xmin";
-    std::string ymin_key = "image/object/bbox/ymin";
-    std::string xmax_key = "image/object/bbox/xmax";
-    std::string ymax_key = "image/object/bbox/ymax";
-    std::string filename_key = "image/filename";
-    label_key = _feature_key_map.at(label_key);
-    text_key = _feature_key_map.at(text_key);
-    xmin_key = _feature_key_map.at(xmin_key);
-    ymin_key = _feature_key_map.at(ymin_key);
-    xmax_key = _feature_key_map.at(xmax_key);
-    ymax_key = _feature_key_map.at(ymax_key);
-    filename_key = _feature_key_map.at(filename_key);
-
-    read_files(path);
-    for (unsigned i = 0; i < _file_names.size(); i++) {
-        std::string fname = path + _file_names[i];
-        uint length;
-        std::cerr << "Reading for object detection - file_name:: " << fname << std::endl;
-        std::ifstream file_contents(fname.c_str(), std::ios::binary);
-        file_contents.seekg(0, std::ifstream::end);
-        length = file_contents.tellg();
-        file_contents.seekg(0, std::ifstream::beg);
-        while (!_last_rec) {
-            read_record(file_contents, length, _image_name, label_key, text_key, xmin_key, ymin_key, xmax_key, ymax_key, filename_key);
-        }
-        _last_rec = false;
-        file_contents.close();
-    }
-    // google::protobuf::ShutdownProtobufLibrary();
-    // print_map_contents();
-}
-
-void TFMetaDataReaderDetection::release(std::string _image_name) {
-    if (!exists(_image_name)) {
-        WRN("ERROR: Given not present in the map" + _image_name);
-        return;
-    }
-    _map_content.erase(_image_name);
-}
-
-void TFMetaDataReaderDetection::release() {
-    _map_content.clear();
-}
-
-void TFMetaDataReaderDetection::read_files(const std::string &_path) {
-    if ((_src_dir = opendir(_path.c_str())) == nullptr)
-        THROW("ERROR: Failed opening the directory at " + _path);
-
-    while ((_entity = readdir(_src_dir)) != nullptr) {
-        if (_entity->d_type != DT_REG)
-            continue;
-
-        _file_names.push_back(_entity->d_name);
-    }
-    if (_file_names.empty())
-        WRN("LabelReader: Could not find any file in " + _path)
-    closedir(_src_dir);
-}
-
-TFMetaDataReaderDetection::TFMetaDataReaderDetection() {
-}
\ No newline at end of file
diff --git a/rocAL/source/readers/image/tf_record_reader.cpp b/rocAL/source/readers/image/tf_record_reader.cpp
deleted file mode 100644
index d31a4ca..0000000
--- a/rocAL/source/readers/image/tf_record_reader.cpp
+++ /dev/null
@@ -1,304 +0,0 @@
-/*
-Copyright (c) 2019 - 2023 Advanced Micro Devices, Inc. All rights reserved.
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-THE SOFTWARE.
-*/
-
-#include "readers/image/tf_record_reader.h"
-#include <iostream>
-#include <sstream>
-#include <string>
-#include <vector>
-
-TFRecordReader::TFRecordReader() {
-    _src_dir = nullptr;
-    _sub_dir = nullptr;
-    _entity = nullptr;
-    _curr_file_idx = 0;
-    _current_file_size = 0;
-    _loop = false;
-    _shuffle = false;
-    _file_id = 0;
-    _last_rec = false;
-    _record_name_prefix = "";
-    _file_count_all_shards = 0;
-}
-
-unsigned TFRecordReader::count_items() {
-    if (_loop)
-        return _file_names.size();
-
-    int ret = ((int)_file_names.size() - _read_counter);
-    return ((ret < 0) ? 0 : ret);
-}
-
-Reader::Status TFRecordReader::initialize(ReaderConfig desc) {
-    auto ret = Reader::Status::OK;
-    _file_id = 0;
-    _folder_path = desc.path();
-    _path = desc.path();
-    _feature_key_map = desc.feature_key_map();
-    _shard_id = desc.get_shard_id();
-    _shard_count = desc.get_shard_count();
-    _batch_count = desc.get_batch_size();
-    _loop = desc.loop();
-    _shuffle = desc.shuffle();
-    _record_name_prefix = desc.file_prefix();
-    _encoded_key = _feature_key_map.at("image/encoded");
-    _filename_key = _feature_key_map.at("image/filename");
-    ret = folder_reading();
-    if (_shard_count > 1 && _batch_count > 1) {
-        int _num_batches = _file_names.size() / _batch_count;
-        int max_batches_per_shard = (_file_count_all_shards + _shard_count - 1) / _shard_count;
-        max_batches_per_shard = (max_batches_per_shard + _batch_count - 1) / _batch_count;
-        if (_num_batches < max_batches_per_shard) {
-            replicate_last_batch_to_pad_partial_shard();
-        }
-    }
-    // shuffle dataset if set
-    if (ret == Reader::Status::OK && _shuffle)
-        std::random_shuffle(_file_names.begin(), _file_names.end());
-    return ret;
-}
-
-void TFRecordReader::incremenet_read_ptr() {
-    _read_counter++;
-    _curr_file_idx = (_curr_file_idx + 1) % _file_names.size();
-}
-size_t TFRecordReader::open() {
-    auto file_path = _file_names[_curr_file_idx];  // Get next file name
-    _last_id = file_path;
-    auto last_slash_idx = _last_id.find_last_of("\\/");
-    if (std::string::npos != last_slash_idx) {
-        _last_id.erase(0, last_slash_idx + 1);
-    }
-    _current_file_size = _file_size[_file_names[_curr_file_idx]];
-    return _current_file_size;
-}
-
-size_t TFRecordReader::read_data(unsigned char *buf, size_t read_size) {
-    auto ret = read_image(buf, _file_names[_curr_file_idx], _file_size[_file_names[_curr_file_idx]]);
-    if (ret != Reader::Status::OK)
-        THROW("TFRecordReader: Error in reading TF records");
-    incremenet_read_ptr();
-    return read_size;
-}
-
-int TFRecordReader::close() {
-    return release();
-}
-
-TFRecordReader::~TFRecordReader() {
-    release();
-}
-
-int TFRecordReader::release() {
-    return 0;
-}
-
-void TFRecordReader::reset() {
-    if (_shuffle)
-        std::random_shuffle(_file_names.begin(), _file_names.end());
-    _read_counter = 0;
-    _curr_file_idx = 0;
-}
-
-Reader::Status TFRecordReader::folder_reading() {
-    if ((_sub_dir = opendir(_folder_path.c_str())) == nullptr)
-        THROW("FileReader ShardID [" + TOSTR(_shard_id) + "] ERROR: Failed opening the directory at " + _folder_path);
-
-    std::vector<std::string> entry_name_list;
-    std::string _full_path = _folder_path;
-    auto ret = Reader::Status::OK;
-    while ((_entity = readdir(_sub_dir)) != nullptr) {
-        std::string entry_name(_entity->d_name);
-        if (strcmp(_entity->d_name, ".") == 0 || strcmp(_entity->d_name, "..") == 0)
-            continue;
-        entry_name_list.push_back(entry_name);
-        // std::cerr<<"\n entry_name::"<<entry_name;
-    }
-    std::sort(entry_name_list.begin(), entry_name_list.end());
-    for (unsigned dir_count = 0; dir_count < entry_name_list.size(); ++dir_count) {
-        std::string subfolder_path = _full_path + "/" + entry_name_list[dir_count];
-        _folder_path = subfolder_path;
-        if (tf_record_reader() != Reader::Status::OK)
-            WRN("FileReader ShardID [" + TOSTR(_shard_id) + "] File reader cannot access the storage at " + _folder_path);
-    }
-    if (_in_batch_read_count > 0 && _in_batch_read_count < _batch_count) {
-        replicate_last_image_to_fill_last_shard();
-        LOG("FileReader ShardID [" + TOSTR(_shard_id) + "] Replicated " + _folder_path + _last_file_name + " " + TOSTR((_batch_count - _in_batch_read_count)) + " times to fill the last batch")
-    }
-    if (!_file_names.empty())
-        LOG("FileReader ShardID [" + TOSTR(_shard_id) + "] Total of " + TOSTR(_file_names.size()) + " images loaded from " + _full_path)
-    closedir(_sub_dir);
-    return ret;
-}
-void TFRecordReader::replicate_last_image_to_fill_last_shard() {
-    // std::cerr<<"\n Replicate last image";
-    for (size_t i = _in_batch_read_count; i < _batch_count; i++) {
-        _file_names.push_back(_last_file_name);
-        _file_size.insert(std::pair<std::string, unsigned int>(_last_file_name, _last_file_size));
-    }
-}
-
-void TFRecordReader::replicate_last_batch_to_pad_partial_shard() {
-    if (_file_names.size() >= _batch_count) {
-        for (size_t i = 0; i < _batch_count; i++)
-            _file_names.push_back(_file_names[i - _batch_count]);
-    }
-}
-
-Reader::Status TFRecordReader::tf_record_reader() {
-    std::string fname = _folder_path;
-    // if _record_name_prefix is specified, read only the records with prefix
-    if (_record_name_prefix.empty() || fname.find(_record_name_prefix) != std::string::npos) {
-        uint file_size;
-        std::ifstream file_contents(fname.c_str(), std::ios::binary);
-        if (!file_contents)
-            THROW("TFRecordReader: Failed to open file " + fname);
-        file_contents.seekg(0, std::ifstream::end);
-        file_size = file_contents.tellg();
-        // std::cerr<<"\n length of the file:: "<<length<<std::endl;
-        file_contents.seekg(0, std::ifstream::beg);
-        auto ret = read_image_names(file_contents, file_size);
-        if (ret != Reader::Status::OK)
-            THROW("TFRecordReader: Error in reading TF records");
-        _last_rec = false;
-        if (_file_names.size() != _file_size.size())
-            std::cerr << "\n Size of vectors are not same";
-        file_contents.close();
-    }
-    return Reader::Status::OK;
-}
-
-size_t TFRecordReader::get_file_shard_id() {
-    if (_batch_count == 0 || _shard_count == 0)
-        THROW("Shard (Batch) size cannot be set to 0")
-    return _file_id % _shard_count;
-}
-
-Reader::Status TFRecordReader::read_image_names(std::ifstream &file_contents, uint file_size) {
-    auto ret = Reader::Status::OK;
-    while (!_last_rec) {
-        uint length;
-        uint64_t data_length;
-        uint32_t length_crc, data_crc;
-
-        length = file_contents.tellg();
-        file_contents.read((char *)&data_length, sizeof(data_length));
-        if (!file_contents)
-            THROW("TFRecordReader: Error in reading TF records")
-        file_contents.read((char *)&length_crc, sizeof(length_crc));
-        if (!file_contents)
-            THROW("TFRecordReader: Error in reading TF records")
-        if (uint(length + data_length + 16) == file_size) {
-            _last_rec = true;
-        }
-        std::unique_ptr<char[]> data(new char[data_length]);
-        file_contents.read(data.get(), data_length);
-        if (!file_contents)
-            THROW("TFRecordReader: Error in reading TF records")
-        _single_example.ParseFromArray(data.get(), data_length);
-        _features = _single_example.features();
-        auto feature = _features.feature();
-        std::string file_path = _folder_path;
-        std::string fname;
-        if (!_filename_key.empty()) {
-            _single_feature = feature.at(_filename_key);
-            fname = _single_feature.bytes_list().value()[0];
-            file_path.append("/");
-            file_path.append(fname);
-        } else {
-            // generate filename based on file_id
-            fname = std::to_string(_file_id);
-            file_path.append("/");
-            file_path.append(fname);
-        }
-        _image_record_starting.insert(std::pair<std::string, uint>(fname, length));
-        _in_batch_read_count++;
-        _in_batch_read_count = (_in_batch_read_count % _batch_count == 0) ? 0 : _in_batch_read_count;
-        _last_file_name = file_path;
-        if (get_file_shard_id() != _shard_id) {
-            incremenet_file_id();
-            _file_count_all_shards++;
-            file_contents.read((char *)&data_crc, sizeof(data_crc));
-            if (!file_contents)
-                THROW("TFRecordReader: Error in reading TF records")
-            continue;
-        }
-        _file_names.push_back(file_path);
-        incremenet_file_id();
-        _file_count_all_shards++;
-        _single_feature = feature.at(_encoded_key);
-        _last_file_size = _single_feature.bytes_list().value()[0].size();
-        _file_size.insert(std::pair<std::string, unsigned int>(_last_file_name, _last_file_size));
-        file_contents.read((char *)&data_crc, sizeof(data_crc));
-        if (!file_contents)
-            THROW("TFRecordReader: Error in reading TF records")
-    }
-    return ret;
-}
-
-Reader::Status TFRecordReader::read_image(unsigned char *buff, std::string file_name, uint file_size) {
-    auto ret = Reader::Status::OK;
-    std::string temp = file_name.substr(0, file_name.find_last_of("\\/"));
-    const size_t last_slash_idx = file_name.find_last_of("\\/");
-    if (std::string::npos != last_slash_idx) {
-        file_name.erase(0, last_slash_idx + 1);
-    }
-    std::ifstream file_contents(temp.c_str(), std::ios::binary);
-    if (!file_contents)
-        THROW("TFRecordReader: Failed to open file " + file_name);
-    auto it = _image_record_starting.find(file_name);
-    if (_image_record_starting.end() == it) {
-        THROW("ERROR: Given name not present in the map" + file_name)
-    }
-    // std::cerr<<"\n image present at loc:: "<<it->second;
-    file_contents.seekg(it->second, std::ifstream::beg);
-    uint64_t data_length;
-    uint32_t length_crc, data_crc;
-    file_contents.read((char *)&data_length, sizeof(data_length));
-    if (!file_contents)
-        THROW("TFRecordReader: Error in reading TF records")
-    file_contents.read((char *)&length_crc, sizeof(length_crc));
-    if (!file_contents)
-        THROW("TFRecordReader: Error in reading TF records")
-    std::unique_ptr<char[]> data(new char[data_length]);
-    file_contents.read(data.get(), data_length);
-    if (!file_contents)
-        THROW("TFRecordReader: Error in reading TF records")
-    _single_example.ParseFromArray(data.get(), data_length);
-    _features = _single_example.features();
-    auto feature = _features.feature();
-    std::string fname;
-    if (!_filename_key.empty()) {
-        _single_feature = feature.at(_filename_key);
-        fname = _single_feature.bytes_list().value()[0];
-    }
-    // if _filename key is empty, just read the encoded/raw feature
-    if (_filename_key.empty() || (fname == file_name)) {
-        _single_feature = feature.at(_encoded_key);
-        memcpy(buff, _single_feature.bytes_list().value()[0].c_str(), _single_feature.bytes_list().value()[0].size());
-    }
-    file_contents.read((char *)&data_crc, sizeof(data_crc));
-    if (!file_contents)
-        THROW("TFRecordReader: Error in reading TF records")
-    file_contents.close();
-    return ret;
-}
diff --git a/tests/python_api/tf_classification_reader.py b/tests/python_api/tf_classification_reader.py
deleted file mode 100644
index baeb969..0000000
--- a/tests/python_api/tf_classification_reader.py
+++ /dev/null
@@ -1,112 +0,0 @@
-# Copyright (c) 2018 - 2023 Advanced Micro Devices, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice shall be included in
-# all copies or substantial portions of the Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-# THE SOFTWARE.
-
-from amd.rocal.plugin.tf import ROCALIterator
-from amd.rocal.pipeline import Pipeline
-import amd.rocal.types as types
-import os
-import amd.rocal.fn as fn
-import tensorflow as tf
-import numpy as np
-from parse_config import parse_args
-
-
-def draw_patches(img, idx, device_type, args=None):
-    import cv2
-    args = parse_args()
-    if device_type == "gpu":
-        try:
-            import cupy as cp
-            img = cp.asnumpy(img)
-        except ImportError:
-            pass
-    if not args.NHWC:
-        img = img.transpose([0, 1, 2])
-    image = cv2.cvtColor(img, cv2.COLOR_RGB2BGR)
-    cv2.imwrite("output_folder/tf_reader/classification/" +
-                str(idx) + "_" + "train" + ".png", image)
-
-
-def main():
-    args = parse_args()
-    # Args
-    image_path = args.image_dataset_path
-    rocal_cpu = False if args.rocal_gpu else True
-    device = "cpu" if rocal_cpu else "gpu"
-    batch_size = args.batch_size
-    one_hot_labels = 1 if args.one_hot_encode else 0
-    num_threads = args.num_threads
-    tensor_layout = types.NHWC if args.NHWC else types.NCHW
-    tf_record_reader_type = 0
-    feature_key_map = {
-        'image/encoded': 'image/encoded',
-        'image/class/label': 'image/class/label',
-        'image/filename': 'image/filename'
-    }
-    try:
-        path = "output_folder/tf_reader/classification/"
-        is_exist = os.path.exists(path)
-        if not is_exist:
-            os.makedirs(path)
-    except OSError as error:
-        print(error)
-    # Create Pipeline instance
-    pipe = Pipeline(batch_size=batch_size, num_threads=num_threads,
-                    device_id=args.local_rank, seed=2, rocal_cpu=rocal_cpu)
-    # Use pipeline instance to make calls to reader, decoder & augmentation's
-    with pipe:
-        inputs = fn.readers.tfrecord(path=image_path, reader_type=tf_record_reader_type, user_feature_key_map=feature_key_map,
-                                     features={
-                                         "image/encoded": tf.io.FixedLenFeature((), tf.string, ""),
-                                         "image/class/label": tf.io.FixedLenFeature([1], tf.int64, -1),
-                                         "image/filename": tf.io.FixedLenFeature((), tf.string, "")
-                                     }
-                                     )
-        jpegs = inputs["image/encoded"]
-        images = fn.decoders.image(
-            jpegs, user_feature_key_map=feature_key_map, output_type=types.RGB, path=image_path)
-        resized = fn.resize(images, resize_width=300,
-                            resize_height=300, output_layout=tensor_layout)
-        if one_hot_labels == 1:
-            labels = inputs["image/class/label"]
-            _ = fn.one_hot(labels, num_classes=1000)
-        pipe.set_outputs(resized)
-    # Build the pipeline
-    pipe.build()
-    # Dataloader
-    image_iterator = ROCALIterator(pipe, device=device)
-    cnt = 0
-    # Enumerate over the Dataloader
-    for i, ([images_array], labels_array) in enumerate(image_iterator, 0):
-        if args.print_tensor:
-            print("\n", i)
-            print("lables_array", labels_array)
-            print("\n\nPrinted first batch with", (batch_size), "images!")
-        for element in list(range(batch_size)):
-            cnt += 1
-            draw_patches(images_array[element], cnt, device, args=args)
-        break
-    image_iterator.reset()
-
-    print("##############################  TF CLASSIFICATION  SUCCESS  ############################")
-
-
-if __name__ == "__main__":
-    main()
diff --git a/tests/python_api/tf_detection_reader.py b/tests/python_api/tf_detection_reader.py
deleted file mode 100644
index 7bae33e..0000000
--- a/tests/python_api/tf_detection_reader.py
+++ /dev/null
@@ -1,164 +0,0 @@
-# Copyright (c) 2018 - 2023 Advanced Micro Devices, Inc. All rights reserved.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice shall be included in
-# all copies or substantial portions of the Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-# THE SOFTWARE.
-
-from amd.rocal.plugin.tf import ROCALIterator
-from amd.rocal.pipeline import Pipeline
-import amd.rocal.types as types
-import tensorflow as tf
-import amd.rocal.fn as fn
-import numpy as np
-import os
-from parse_config import parse_args
-
-
-def get_onehot(image_labels_array, num_classes):
-    one_hot_vector_list = []
-    for label in image_labels_array:
-        one_hot_vector = np.zeros(num_classes)
-        if label[0] != 0:
-            np.put(one_hot_vector, label[0] - 1, 1)
-        one_hot_vector_list.append(one_hot_vector)
-
-    one_hot_vector_array = np.array(one_hot_vector_list)
-
-    return one_hot_vector_array
-
-
-def get_weights(num_bboxes):
-    weights_array = np.zeros(num_bboxes)
-    for pos in list(range(num_bboxes)):
-        np.put(weights_array, pos, 1)
-    return weights_array
-
-
-def draw_patches(img, idx, bboxes, device_type, args=None):
-    import cv2
-    args = parse_args()
-    if device_type == "gpu":
-        try:
-            import cupy as cp
-            img = cp.asnumpy(img)
-        except ImportError:
-            pass
-    if not args.NHWC:
-        img = img.transpose([0, 1, 2])
-    image = cv2.cvtColor(img, cv2.COLOR_RGB2BGR)
-    image = cv2.normalize(image, None, alpha=0, beta=255,
-                          norm_type=cv2.NORM_MINMAX, dtype=cv2.CV_32F)
-    for (l, t, r, b) in bboxes:
-        loc_ = [l, t, r, b]
-        color = (255, 0, 0)
-        thickness = 2
-        image = cv2.UMat(image).get()
-        image = cv2.rectangle(image, (int(loc_[0]), int(loc_[1])), (int(
-            (loc_[2])), int((loc_[3]))), color, thickness)
-        cv2.imwrite("output_folder/tf_reader/detection/" +
-                    str(idx) + "_" + "train" + ".png", image)
-
-
-def main():
-    args = parse_args()
-    # Args
-    image_path = args.image_dataset_path
-    num_classes = 91
-    rocal_cpu = False if args.rocal_gpu else True
-    device = "cpu" if rocal_cpu else "gpu"
-    batch_size = args.batch_size
-    num_threads = args.num_threads
-    tensor_layout = types.NHWC if args.NHWC else types.NCHW
-    tf_record_reader_type = 1
-    feature_key_map = {
-        'image/encoded': 'image/encoded',
-        'image/class/label': 'image/object/class/label',
-        'image/class/text': 'image/object/class/text',
-        'image/object/bbox/xmin': 'image/object/bbox/xmin',
-        'image/object/bbox/ymin': 'image/object/bbox/ymin',
-        'image/object/bbox/xmax': 'image/object/bbox/xmax',
-        'image/object/bbox/ymax': 'image/object/bbox/ymax',
-        'image/filename': 'image/filename'
-    }
-    try:
-        path = "output_folder/tf_reader/detection"
-        is_exist = os.path.exists(path)
-        if not is_exist:
-            os.makedirs(path)
-    except OSError as error:
-        print(error)
-
-    pipe = Pipeline(batch_size=batch_size, num_threads=num_threads,
-                    device_id=args.local_rank, seed=2, rocal_cpu=rocal_cpu)
-    with pipe:
-        inputs = fn.readers.tfrecord(path=image_path, reader_type=tf_record_reader_type, user_feature_key_map=feature_key_map,
-                                     features={
-                                         'image/encoded': tf.io.FixedLenFeature((), tf.string, ""),
-                                         'image/class/label': tf.io.FixedLenFeature([1], tf.int64,  -1),
-                                         'image/class/text': tf.io.FixedLenFeature([], tf.string, ''),
-                                         'image/object/bbox/xmin': tf.io.VarLenFeature(dtype=tf.float32),
-                                         'image/object/bbox/ymin': tf.io.VarLenFeature(dtype=tf.float32),
-                                         'image/object/bbox/xmax': tf.io.VarLenFeature(dtype=tf.float32),
-                                         'image/object/bbox/ymax': tf.io.VarLenFeature(dtype=tf.float32),
-                                         'image/filename': tf.io.FixedLenFeature((), tf.string, "")
-                                     }
-                                     )
-        jpegs = inputs["image/encoded"]
-        _ = inputs["image/class/label"]
-        decoded_images = fn.decoders.image_random_crop(jpegs, user_feature_key_map=feature_key_map, output_type=types.RGB,
-                                                       random_aspect_ratio=[
-                                                           0.8, 1.25],
-                                                       random_area=[0.1, 1.0],
-                                                       num_attempts=100, path=image_path)
-        resized = fn.resize(decoded_images, resize_width=300,
-                            resize_height=300, output_layout=tensor_layout)
-        pipe.set_outputs(resized)
-    pipe.build()
-    image_iterator = ROCALIterator(pipe, device=device)
-
-    cnt = 0
-    for i, ([images_array], bboxes_array, labels_array, num_bboxes_array) in enumerate(image_iterator, 0):
-        print("ROCAL augmentation pipeline - Processing batch %d....." % i)
-
-        for element in list(range(batch_size)):
-            cnt += 1
-            if args.print_tensor:
-                print("Processing image %d....." % element)
-            features_dict = {
-                "image": images_array[element],
-                "true_image_shape": np.array([len(images_array[element]), len(images_array[element, 0]), len(images_array[element, 0, 0])])
-            }
-            labels_dict = {
-                "num_groundtruth_boxes": num_bboxes_array[element],
-                "groundtruth_boxes": bboxes_array[element],
-                "groundtruth_classes": get_onehot(labels_array[element], num_classes),
-                "groundtruth_weights": get_weights(num_bboxes_array[element])
-            }
-            processed_tensors = (features_dict, labels_dict)
-            if args.print_tensor:
-                print("\nPROCESSED_TENSORS:\n", processed_tensors)
-            draw_patches(images_array[element], cnt,
-                         bboxes_array[element], device, args=args)
-        print("\n\nPrinted first batch with", (batch_size), "images!")
-        break
-    image_iterator.reset()
-
-    print("##############################  TF DETECTION  SUCCESS  ############################")
-
-
-if __name__ == "__main__":
-    main()
-- 
2.41.1

